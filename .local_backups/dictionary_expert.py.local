"""
Dictionary Expert - Provides word definitions and morphological analysis.

This expert handles queries about word meanings, structure, and usage:
- "Kio signifas 'bela'?" → What does 'bela' mean?
- "Kiel oni konstruas 'malbona'?" → How is 'malbona' constructed?
- "Difinu 'amikino'" → Define 'amikino'

Uses pure symbolic processing (no neural networks) by analyzing morphemes.
"""

from typing import Dict, Any, List, Optional
import logging

from .base import Expert
from klareco.parser import parse_word

logger = logging.getLogger(__name__)


class DictionaryExpert(Expert):
    """
    Expert for word definitions and morphological analysis.

    Provides symbolic word definitions by analyzing morpheme structure.
    """

    # Common root meanings (expandable)
    ROOT_DEFINITIONS = {
        'bel': 'beautiful',
        'bon': 'good',
        'grand': 'big, large',
        'mal': 'opposite (prefix)',
        'plen': 'full',
        'san': 'healthy',
        'vid': 'see',
        'dir': 'say',
        'far': 'do, make',
        'est': 'be',
        'hav': 'have',
        'don': 'give',
        'ven': 'come',
        'ir': 'go',
        'am': 'love',
        'parol': 'speak',
        'labor': 'work',
        'help': 'help',
        'kur': 'run',
        'salt': 'jump',
        'kant': 'sing',
        'leg': 'read',
        'skrib': 'write',
        'hom': 'human, person',
        'vir': 'man (male)',
        'amik': 'friend',
        'patr': 'father',
        'matr': 'mother',
        'frat': 'brother',
        'infan': 'child',
        'dom': 'house',
        'urb': 'city',
        'land': 'land, country',
        'mond': 'world',
        'tag': 'day',
        'nokt': 'night',
        'jar': 'year',
        'temp': 'time',
    }

    # Suffix meanings
    SUFFIX_DEFINITIONS = {
        'ul': 'person characterized by',
        'in': 'female',
        'et': 'small, diminutive',
        'eg': 'large, augmentative',
        'ej': 'place for',
        'il': 'tool for',
        'ar': 'collection of',
        'ad': 'continuous action',
        'aĉ': 'bad quality',
        'an': 'member of',
        'ebl': 'able to be',
        'end': 'must be',
        'ind': 'worthy of',
        'ig': 'cause to be',
        'iĝ': 'become',
    }

    def __init__(self):
        """Initialize Dictionary Expert."""
        super().__init__("Dictionary Expert")

    def can_handle(self, ast: Dict[str, Any]) -> bool:
        """
        Check if this is a dictionary query.

        Looks for:
        - "Kio signifas...?" (What does ... mean?)
        - "Difinu..." (Define...)
        - "Kiel oni konstruas...?" (How is ... constructed?)

        Args:
            ast: Parsed query AST

        Returns:
            True if this is a dictionary query
        """
        if not ast or ast.get('tipo') != 'frazo':
            return False

        # Extract all words
        words = self._extract_all_words(ast)
        words_lower = [w.lower() for w in words]

        # Check for definition keywords
        definition_keywords = {
            'signif',  # signifas = means
            'difin',   # difinu = define
            'konstru', # konstruas = constructs
            'signif',  # root of signifas
        }

        has_definition_keyword = any(
            any(keyword in word for keyword in definition_keywords)
            for word in words_lower
        )

        return has_definition_keyword

    def estimate_confidence(self, ast: Dict[str, Any]) -> float:
        """
        Estimate confidence in handling this query.

        Args:
            ast: Parsed query AST

        Returns:
            Confidence score 0.0-1.0
        """
        if not self.can_handle(ast):
            return 0.0

        words = self._extract_all_words(ast)
        words_lower = [w.lower() for w in words]

        # High confidence for explicit definition requests
        if 'signifas' in words_lower or 'difinu' in words_lower:
            return 0.95

        # Moderate confidence for construction questions
        if 'konstruas' in words_lower or 'konstruita' in words_lower:
            return 0.85

        return 0.7

    def execute(self, ast: Dict[str, Any]) -> Dict[str, Any]:
        """
        Execute dictionary query.

        Args:
            ast: Parsed query AST

        Returns:
            Response with word definition and analysis
        """
        # Validate AST
        if not ast or ast.get('tipo') != 'frazo':
            return {
                'answer': 'Mi ne povas procezi malplenan aŭ malvalidan demandon.',
                'confidence': 0.0,
                'expert': self.name,
                'error': 'Invalid or empty AST'
            }

        try:
            # Extract target word from query
            target_word = self._extract_target_word(ast)

            if not target_word:
                return {
                    'answer': 'Mi ne povas trovi la vorton por difini.',
                    'confidence': 0.0,
                    'expert': self.name,
                    'error': 'No target word found'
                }

            # Analyze the word
            analysis = self._analyze_word(target_word)

            # Format answer
            answer = self._format_definition(target_word, analysis)

            return {
                'answer': answer,
                'confidence': 0.9,
                'expert': self.name,
                'word': target_word,
                'analysis': analysis,
                'explanation': f'Morfologia analizo de "{target_word}"'
            }

        except Exception as e:
            logger.error(f"Dictionary lookup failed: {e}", exc_info=True)
            return {
                'answer': f'Eraro dum vort-analizo: {str(e)}',
                'confidence': 0.0,
                'expert': self.name,
                'error': str(e)
            }

    def _extract_all_words(self, ast: Dict[str, Any]) -> List[str]:
        """Extract all words from AST recursively."""
        words = []

        if isinstance(ast, dict):
            if ast.get('tipo') == 'vorto':
                word = ast.get('plena_vorto', '') or ast.get('radiko', '')
                if word:
                    words.append(word)

            for value in ast.values():
                if isinstance(value, (dict, list)):
                    words.extend(self._extract_all_words(value))

        elif isinstance(ast, list):
            for item in ast:
                words.extend(self._extract_all_words(item))

        return words

    def _extract_target_word(self, ast: Dict[str, Any]) -> Optional[str]:
        """
        Extract the word being asked about.

        Looks for quoted words or words after definition keywords.
        """
        # Simple heuristic: get last noun or proper noun
        words = []

        def extract(node):
            if isinstance(node, dict):
                if node.get('tipo') == 'vorto':
                    vortspeco = node.get('vortspeco', '')
                    if vortspeco in ['substantivo', 'nomo', 'adjektivo', 'verbo']:
                        radiko = node.get('radiko', '')
                        if radiko and radiko not in ['kio', 'kiu', 'difin', 'signif']:
                            words.append(node.get('plena_vorto', radiko))

                for value in node.values():
                    if isinstance(value, (dict, list)):
                        extract(value)
            elif isinstance(node, list):
                for item in node:
                    extract(item)

        extract(ast)

        # Return last meaningful word
        return words[-1] if words else None

    def _analyze_word(self, word: str) -> Dict[str, Any]:
        """
        Analyze word morphology.

        Args:
            word: Esperanto word to analyze

        Returns:
            Dict with morphological analysis
        """
        try:
            # Parse the word
            word_ast = parse_word(word)

            # Extract components
            radiko = word_ast.get('radiko', '')
            prefikso = word_ast.get('prefikso')
            sufiksoj = word_ast.get('sufiksoj', [])
            vortspeco = word_ast.get('vortspeco', 'unknown')
            nombro = word_ast.get('nombro', 'singularo')
            kazo = word_ast.get('kazo', 'nominativo')

            # Look up meanings
            root_meaning = self.ROOT_DEFINITIONS.get(radiko.lower(), f"[root: {radiko}]")

            suffix_meanings = []
            for suffix in sufiksoj:
                meaning = self.SUFFIX_DEFINITIONS.get(suffix, f"[suffix: {suffix}]")
                suffix_meanings.append((suffix, meaning))

            return {
                'radiko': radiko,
                'radiko_meaning': root_meaning,
                'prefikso': prefikso,
                'sufiksoj': sufiksoj,
                'suffix_meanings': suffix_meanings,
                'vortspeco': vortspeco,
                'nombro': nombro,
                'kazo': kazo,
                'parse_success': True
            }

        except Exception as e:
            logger.warning(f"Could not parse word '{word}': {e}")
            return {
                'parse_success': False,
                'error': str(e)
            }

    def _format_definition(self, word: str, analysis: Dict[str, Any]) -> str:
        """
        Format word definition from analysis.

        Args:
            word: Original word
            analysis: Morphological analysis

        Returns:
            Formatted definition string
        """
        if not analysis.get('parse_success'):
            return f"Mi ne povas analizi la vorton '{word}'."

        parts = []

        # Word and part of speech
        vortspeco = analysis.get('vortspeco', 'unknown')
        vortspeco_map = {
            'substantivo': 'substantivo (noun)',
            'adjektivo': 'adjektivo (adjective)',
            'verbo': 'verbo (verb)',
            'adverbo': 'adverbo (adverb)'
        }
        vortspeco_str = vortspeco_map.get(vortspeco, vortspeco)

        parts.append(f"'{word}' estas {vortspeco_str}.")

        # Root meaning
        radiko = analysis.get('radiko', '')
        radiko_meaning = analysis.get('radiko_meaning', '')
        if radiko:
            parts.append(f"Radiko: '{radiko}' = {radiko_meaning}")

        # Prefix
        prefikso = analysis.get('prefikso')
        if prefikso:
            parts.append(f"Prefikso: {prefikso}-")

        # Suffixes
        suffix_meanings = analysis.get('suffix_meanings', [])
        if suffix_meanings:
            suffix_strs = [f"-{suf} ({meaning})" for suf, meaning in suffix_meanings]
            parts.append(f"Sufiksoj: {', '.join(suffix_strs)}")

        # Grammatical info
        nombro = analysis.get('nombro', '')
        kazo = analysis.get('kazo', '')
        if nombro == 'pluralo':
            parts.append("Numero: pluralo (plural)")
        if kazo == 'akuzativo':
            parts.append("Kazo: akuzativo (accusative)")

        return " ".join(parts)


# Export
__all__ = ['DictionaryExpert']
